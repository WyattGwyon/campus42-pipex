fcntl.h
int name, int flags, mode_t mode)
	returns a nonnegative int fd, the lowest fd not currently open for the process
	if pathname does not exist, using O_CREAT flag can create it
	mode is not required and will set to a default.
	remains open across an execve()
	returns -1 if failed

	1) Create or overwrite a file:
		O_WRONLY | O_CREAT | O_TRUNC
	2) Append to a file (or create if missing)
		O_APPEND | O_WRONLY | O_CREAT
	3) Open existing file for reading
		O_RDONLY
	4) Open existing file for reading and writing
		O_RDWR
	5) exclusive creation
		O_CREAT | O_WRONLY | O_EXCL


unistd.h
int close(int fd)
	 errors should be checked


unistd.h
ssize_t read(int fd, void *buf, size_t count)
	read up to count bytes from fd into buffer starting at buf
	on success the number of bytes read is retruned (0 indicates EOF)
	the file position is advanced by this number.
	the number of bytes read can be less than the buffer.
	-1 means error

unistd.h
ssize_t write(int fd, const void *bug, size_t count)
	writes up to count bytes fromthe buffer starting at buf into the file referred to fd
	writing takes place at the file offset
	file offset is incremented by the number of bytes actually written.
	the file offset is set th EOF before writing when file was opened with O_APPEND
	partial writes can occur because of insufficent space on disk, 
	or a blocked write()was interrupted by a signal handler after it had transferred some but not allrequested bytes.
	another write call will transfer remaining bytes.
	returns -1 on error

malloc
free

stdio.h
void perror(const char *s)
	fucntion produces a message o n standard error describing the last error 
	encountered during a call to a sysem or libraray function
	the argument string should include the name of the function that incurred the error
	converts errno variable (a value describing what went wrong) into something that is human readable
	sys_errlist[] is a global error list but the use of strerror is preferred instead
	if s is not NULL and *s is nto a null byte the arg string s is printed followed by a colon and a blank
	then an error message correspoing to the current value of errno and a new line
	this is for fast simple error messaging, 
	performs relatively the same function as ptrinf(..., strerror(errno))

string.h
char *strerror(int errnum)
	returns a pointer to a string that describes that error code int eh argument errnum
	for example if errnum is EINVAL, the returned descriptio will be "Invalid argument"
	this serves for more flexible formatting and must be printed

unistd.h
int access(const char *pathname, int mode)
	checks whether the calling process can access the file pathname 
	the check is done using the calling processs real UID and GID
	answers the question "can the user who invoked this binary read/write/execute this file?"
	the mode is either F_OK or a mask consisting of the bitwise OR of one or more of R_OK, W_OK X_OK
	return value is 0 on success 
	on failure, at least one mode was denied, or the file does not exist , returns -1

unistd.h
int dup(int oldfd)
	system call creates a copy of the fd
	the old and the new fds can be used interchangably, 
	they refer to the same open fd and share same offset and status flags
	returns new fd

unistd.h
int dup2(int oldfd, int newfd)
	does the same as dup(), but instead of automatically using a new fd
	it uses the indicated newfd
	if the newfd was previously open, it is silently closed before being reused
	if oldfd is not a valid file descriptor, then the call fails, and newfd is not closed
	if oldfd is a valid file descriptor, 
	and newfd has the same value as oldfd, then dup2 does nothing and returns newfd
	oldfd donates its data to file descriptor indicated as newfd
	dup2 closes the 2nd arg (newfd), if it is open, thereby removing any previous reference, to terminal for example
	then associates oldfd to the newfd

unistd.h
int execve(const char *pathname, char *const argv[], char *const envp[])
	executes the program referred to by pathname, 
	this causes the program that is currently being run by the calling process to be replaced with a new program
	with newly initialised stack, heap, and initilaized and uninitialised data segments
	pathname must be a binaty exectuable, or a script starting with a shebang
	argv contains args for the binary passed for pathname
	envp is the environment of the new program which must be terminated by a NULL pointer

stdlib.h
void exit(int status)
	causes normal process terminaition and the least signigicant byte of status is returned to parent

unistd.h
pid_t fork(void)
	creates new process by duplciating the calling proccess. the new process is referred to as the chid proccess
	the child and parent run on separate memory spacces but both memory sapces have the saem content
	child process is 

unistd.h
int pipe(int fd[2])
	fd[0] is read end
	fd[1] is write end
	data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe
	0 is returned on success
	-1 is returned on failure
	pipe populates the array with two file descriptors, {3,4} for example
	and it gives exclusive read permission to the first file descriptor
	and it gives exclusive write permission to the second file descriptor

unlink
wait
waitpid

Parent Process
   |
   | creates a pipe: fds[2] (read end fds[0], write end fds[1])
   |
   +--- fork() --> Child Process 1  --> exec("ls")
   |               (writer)
   |               stdout redirected to fds[1]
   |
   +--- fork() --> Child Process 2  --> exec("grep .c")
                   (reader)
                   stdin redirected from fds[0]


In More Depth
Parent Process
   |
   | creates pipe: fds[2] 
   | fds[0] = read end, fds[1] = write end
   |
   +--- fork() --> Child Process 1 (writer)
   |               Command: "ls"
   |               close(fds[0])           // unused read end
   |               dup2(fds[1], STDOUT)    // stdout -> pipe write end
   |               close(fds[1])           // original fd no longer needed
   |               exec("ls")
   |
   +--- fork() --> Child Process 2 (reader)
                   Command: "grep .c"
                   close(fds[1])           // unused write end
                   dup2(fds[0], STDIN)     // stdin -> pipe read end
                   close(fds[0])           // original fd no longer needed
                   exec("grep .c")

https://www.rozmichelle.com/pipes-forks-dups/
https://www.fmc-modeling.org/category/projects/apache/amp/A_4_Pipes.html			
https://excalidraw.com/#json=aGcfyppXP9ulhd6aiWKEA,pJd7nl5WXPCydPgV4Rtx9A
###############################################################
int pipe1[2];
int pipe2[2];
pipe(pipe1);
pipe(pipe2);
int pid = fork();


   Kernel Buffers
      +-------------------+     +-------------------+
pipe1 |      buffer       |     |      buffer       | pipe2
      +-------------------+     +-------------------+
        ^           ^                 ^           ^
        |           |                 |           |
Parent: fd[0]     fd[1]             fd[0]       fd[1]
Child:  fd[0]     fd[1]             fd[0]       fd[1]

###############################################################
int pipe1[2];
pipe(pipe1);

int pid1 = fork();
int pid2 = fork();

Process		Origin				FDs after fork
P			original			pipe1[0], pipe1[1]
C1			pid1 fork			pipe1[0], pipe1[1]
C2			pid2 fork from P	pipe1[0], pipe1[1]
C3			pid2 fork from C1	pipe1[0], pipe1[1]

All four processes share the same kernel pipe buffer, but each has its own fd table
################################################################


Parent Process
   |
   | creates pipe1: pipe1[2]
   |   pipe1[0] = read end, pipe1[1] = write end
   |
   +--- fork() --> Child Process 1 (writer: "ls")
   |               close(pipe1[0])                  // unused read end
   |               dup2(pipe1[1], STDOUT)           // stdout -> pipe1 write end
   |               close(pipe1[1])                  // original fd no longer needed
   |               exec("ls")
   |
   | creates pipe2: pipe2[2]
   |   pipe2[0] = read end, pipe2[1] = write end
   |
   +--- fork() --> Child Process 2 (middle: "grep .c")
   |               close(pipe1[1])                  // no longer writing to pipe1
   |               dup2(pipe1[0], STDIN)            // stdin -> pipe1 read end
   |               close(pipe1[0])
   |               close(pipe2[0])                  // unused read end of pipe2
   |               dup2(pipe2[1], STDOUT)           // stdout -> pipe2 write end
   |               close(pipe2[1])
   |               exec("grep .c")
   |
   | creates pipe3: pipe2[2]
   |   pipe3[0] = read end, pipe3[1] = write end
   |
   +--- fork() --> Child Process 3 (middle: "grep .c")
   |               close(pipe2[1])                  // no longer writing to pipe2
   |               dup2(pipe2[0], STDIN)            // stdin -> pipe2 read end
   |               close(pipe2[0])
   |               close(pipe3[0])                  // unused read end of pipe3
   |               dup2(pipe3[1], STDOUT)           // stdout -> pipe3 write end
   |               close(pipe3[1])
   |               execve("grep .c")
   |
   +--- fork() --> Child Process 4 (reader: "sort")
                   close(pipe3[1])                  // unused write end
                   dup2(pipe3[0], STDIN)            // stdin -> pipe3 read end
                   close(pipe3[0])
                   exec("sort")



++++++++++++++++++
Planning of structures
information need before we start the function of the pipes

char	*infile
char	*outfile
char	**commands (array of strings of input commands)
char	**command_paths (array of strings, command paths expanded)
int		command_cnt

we can create stucts that can be members of other structs so as to have
deeper structs.

this will require at the same time deeper freeing.




Parse args correctly
check that cmd is executable/exists
check that permissions exist to open file 
check that permissions exist to execute command
manage certain errors correctly
when cmd does not exist


t_pipex pipex
char *infile -> "hello.txt" or "Makefile"
char *outfile -> "out.txt"
int  cmd_cnt -> argc - 3 (if first and last args are files)
t_cmd **cmd -> {"ls -la", {"ls", "-la", NULL}, "/usr/bin/ls"}, 
				{"wc -l",{"wc", "-l", NULL}, "/usr/bin/wc" },
				 "echo" etc, 
				 "mv" etc

pipex.cmd 
char *raw_cmd -> "ls -la", "wc -l", "echo 'hello world'", "mv test.txt move.txt"
char **argv -> {"ls", "-la", NULL}, {"wc", "-l", NULL},
				{"echo", "'hello world'"}, 
				{"mv", "test.txt","out.txt", NULL}
char *path -> "/usr/bin/ls", "/usr/bin/echo", "/usr/bin/wc",
				"/usr/bin/mv"

to execute for each argv that is a command
execve(pipex.cmd.path, pipex.cmd.argv, environ)

V^^^correction to above^^^^^V
t_pipex pipex
 ├─ infile   -> "infile"
 ├─ outfile  -> "outfile"
 ├─ cmd_cnt  -> 2
 └─ commands -> [ t_cmd*, t_cmd* ]
                 │        │
                 ▼        ▼
               t_cmd     t_cmd
                │         │
                ▼         ▼
 raw_cmd -> "ls -la"   raw_cmd -> "wc -l"
 argv    -> ["ls","-la",NULL]   argv -> ["wc","-l",NULL]
 path    -> "/usr/bin/ls"       path -> "/usr/bin/wc"

 pipex.commands
   ┌──────────────────────┐
   │ [0] -> (t_cmd struct)│
   │ [1] -> (t_cmd struct)│
   │ [2] -> (t_cmd struct)│
   └──────────────────────┘

execve(pipex.commands[i]->path, pipex.commands[i]->argv, environ);


Your shell is responsible for:

	parsing commands and arguments

	resolving them in $PATH

	handling redirections / pipes

	calling fork() + execve()

	handling wait() + exit status

	printing errors related to the shell itself 
	(like command not found, bad syntax, missing infile/outfile, etc.)

The executed program is responsible for:

	any errors that occur inside it 
	(ls: cannot access file: No such file or directory, gio: ..., etc.)

	those errors are not your concern — 
	the program replaces your child process after execve().